/*
91. 解码方法
https://leetcode-cn.com/problems/decode-ways/
一条包含字母 A-Z 的消息通过以下方式进行了编码：

'A' -> 1
'B' -> 2
...
'Z' -> 26

给定一个只包含数字的非空字符串，请计算解码方法的总数。
题目数据保证答案肯定是一个 32 位的整数。

示例 1：
输入："12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。

示例 2：
输入："226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。

示例 3：
输入：s = "0"
输出：0

提示：
    1 <= s.length <= 100
    s 只包含数字，并且可以包含前导零。
*/

/*
解法：需要注意的是，本题与剑指offer略有区别，主要是1才对应'A'，所以需要判断0的不合理性。
执行用时：1 ms, 在所有 Java 提交中击败了99.98% 的用户
内存消耗：37.1 MB, 在所有 Java 提交中击败了43.34% 的用户
*/
class Solution {
    public int numDecodings(String s) {
        if(s.length() == 0 || s.charAt(0) == '0')
            return 0;
        // 设置初值，分别对应于i-2与i-1。
        // 细想一下，对于第二个元素，本身属于1~9，是一种情况(因此cur = 1)；与第一个元素构成10~26，又是一种情况(因此pre = 1)。
        int pre = 1, cur = 1;   
        for(int i = 1; i < s.length(); i++) {
            String ch = s.substring(i - 1, i + 1);   // 取子串
            int temp = 0;  // 包含当前字符的解码方法数
            if(s.charAt(i) != '0') temp += cur;   // 如果当前字符不是0，那么本身可以解码，因此加上cur
            if(ch.compareTo("10") >= 0 && ch.compareTo("26") <= 0)  // 如果和前面字符能够组成有效编码，那么需要加上pre
                temp += pre;
            pre = cur;   // 更新
            cur = temp;
        }
        // 循环有一个trick在于，如"123045"这样的字符串，"30"是无论如何都无法被解码的。
        // 但在循环中，遇到"0"后，因为"0"与"30"的存在，所以得到temp = 0，更新之后cur = 0；
        // 到了下一个字符，因为cur = 0，而且无法与前面的"0"组成有效字符，所以得到的temp仍为0；
        // 由此会导致pre和cur都是0，所以最后结果也肯定是0了。
        // 所以在循环中可以在末尾加判断————if(temp == 0) return 0;
        // 执行用时：1 ms, 在所有 Java 提交中击败了99.98% 的用户
        // 内存消耗：36.8 MB, 在所有 Java 提交中击败了82.70% 的用户
        return cur;
    }
}


